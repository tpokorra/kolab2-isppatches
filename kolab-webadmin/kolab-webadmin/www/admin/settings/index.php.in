<?php
require_once('@kolab_php_module_prefix@admin/include/mysmarty.php');
require_once('@kolab_php_module_prefix@admin/include/headers.php');
require_once('@kolab_php_module_prefix@admin/include/locale.php');
require_once('@kolab_php_module_prefix@admin/include/authenticate.php');
require_once('@kolab_php_module_prefix@admin/include/customer.php');

$errors = array();

/**** Authentication etc. ***/
$sidx = 'service';

if( $auth->group() != 'admin' && $auth->group() != 'maintainer' ) {
   array_push($errors, _("Error: You don't have Permissions to access this Menu"));
   $access_denied = true;
}

require_once('@kolab_php_module_prefix@admin/include/menu.php');

/**** Submenu for current page ***/
$menuitems[$sidx]['selected'] = 'selected';

/**** Extract data from LDAP, fill forms, write back to LDAP ***/


function postvalue( $varname )
{
  if( isset($_REQUEST[$varname]) && $_REQUEST[$varname] == true ) return 'TRUE';
  else return 'FALSE';
}

function getCustomers() {
	global $ldap;
	if($_SESSION['customer_dn'] == $_SESSION['base_dn']
			&& !$_SESSION['ignore_customer'])
		return array();
	$filter = '';
	if($_SESSION['customer_dn'] != $_SESSION['base_dn'])
		$filter = '(cn=' . canonicalizeEntity($_SESSION['customer_dn']) . ')';
	if(($result = $ldap->search( "cn=customers,cn=internal," .
			$_SESSION['base_dn'], "(&(objectClass=kolabGroupOfNames)$filter)",
			array(
				'cn',
				'kolabHomeServer',
				'description'
			)))) {
		ldap_sort($ldap->connection,$result,'cn');
		foreach($ldap->getEntries() as $v)
			if(is_array($v))
				$customer[] = array(
					"cn" => $v["cn"][0],
					"description" => $v["description"][0],
					"kolabhomeserver"  => $v["kolabhomeserver"][0],
				);
		return $customer;
	}
	else
		return false;
}

function ldap_delete_recursive($ds, $dn, $recursive = false) {
	if(!$recursive)
		return ldap_delete($ds,$dn);
	//search for sub entries
	$sr = ldap_list($ds, $dn, "ObjectClass=*", array(""));
	$info = ldap_get_entries($ds, $sr);
	for($i = 0; $i < $info['count']; $i++) {
		// delete sub entries recursively
		$result = ldap_delete_recursive($ds, $info[$i]['dn'], $recursive);
		if(!$result)
			// return result code if delete fails
			return $result;
	}
	return ldap_delete($ds,$dn);
}

function extract_ldap_values()
{
  global $ldap;
  global $pop3;
  global $pop3s;
  global $imap;
  global $imaps;
  global $sieve;
  global $http;
  global $httpallowunauthfb;
  global $amavis;
  global $quotawarn;
  global $freebusypast;
  global $postfixmydomain;
  global $postfixmydestination;
  global $customers;
  global $postfixmynetworks;
  global $postfixallowunauth;
  global $postfixrelayhost;
  global $postfixrelayport;
  global $kolabhost;
  global $kolabfilterverifyfrom;
  global $kolabfilterallowsender;
  global $kolabfilterrejectforgedfrom;

  // Get values from LDAP
  if (($result = ldap_read($ldap->connection, "k=kolab,".$_SESSION['base_dn'], '(objectclass=*)')) &&
	  ($entry = ldap_first_entry($ldap->connection, $result)) &&
	  ($attrs = ldap_get_attributes($ldap->connection, $entry))) {
	$pop3 = $attrs['cyrus-pop3'][0];
	$pop3s = $attrs['cyrus-pop3s'][0];
	$imap = $attrs['cyrus-imap'][0];
	$imaps = $attrs['cyrus-imaps'][0];
	$sieve = $attrs['cyrus-sieve'][0];
	$http = $attrs['apache-http'][0];
	$httpallowunauthfb = $attrs['apache-allow-unauthenticated-fb'][0];
	$amavis = $attrs['postfix-enable-virus-scan'][0];
	$quotawarn = $attrs['cyrus-quotawarn'][0];
	$freebusypast = $attrs['kolabFreeBusyPast'][0];
	$postfixmydomain = $attrs['postfix-mydomain'][0];
	$postfixmydestination = $attrs['postfix-mydestination'];
	unset($postfixmydestination['count']);
	$customers = getCustomers();
	unset( $attrs['postfix-mynetworks']['count'] );
	$postfixmynetworks = join(', ',$attrs['postfix-mynetworks']);
	$postfixallowunauth = $attrs['postfix-allow-unauthenticated'][0];
	$postfixrelayhost = $attrs['postfix-relayhost'][0];
	$postfixrelayport = $attrs['postfix-relayport'][0];
	$kolabhost = $attrs['kolabHost'];
	unset( $kolabhost['count'] );
	$kolabfilterverifyfrom = $attrs['kolabfilter-verify-from-header'][0];
	$kolabfilterallowsender = $attrs['kolabfilter-allow-sender-header'][0];
	$kolabfilterrejectforgedfrom = $attrs['kolabfilter-reject-forged-from-header'][0];
	ldap_free_result($result);
  }
}

function toboolstr( $b ) { return ( $b == 'TRUE' )?'true':'false'; }


extract_ldap_values();

$domains = $ldap->domainsOfSelectedCustomer();
$domain_count = 0;
foreach( $domains as $domain ) {
  // Write back to LDAP
  if( $_REQUEST['submitsystemalias_'.$domain_count] ) {
	$mail = trim($_REQUEST['systemaliasmail_'.$domain_count]);
	$dn = $ldap->dnForMailOrAlias( $mail );
	if( !$dn ) {
	  $errors[] = sprintf(_("No account found for email address %s"), $mail);
	} else {
	  foreach( array( 'postmaster', 'hostmaster', 'abuse', 'virusalert', 'MAILER-DAEMON' ) as $group ) {
		$gadr = $group.'@'.$domain;
		$attrs = array( 'objectClass' => array( 'top', 'kolabGroupOfNames' ),
						'cn' => $gadr,
						'mail' => $gadr,
						'member' => $dn );
		$domainOwner = $ldap->customerOfDomain($domain);
		if($domainOwner)
			$aliasSubtree = "cn=$domainOwner," . $_SESSION['base_dn'];
		else
			$aliasSubtree = $_SESSION['base_dn'];
		if(!ldap_add($ldap->connection, "cn=$gadr," . $aliasSubtree, $attrs)) {
		  $errors[] = sprintf(_("LDAP Error: Failed to add distribution list %s: %s"), $gadr, $ldap->error());
		} else {
		  $messages[] = sprintf( _("Successfully created distribution list %s"), $gadr);
		}
	  }
	}
  }
  $domain_count++;
}

if( $_REQUEST['submitservices'] ) {
  $attrs = array();
  if( postvalue( 'pop3' ) != $pop3 )   $attrs['cyrus-pop3'] = postvalue( 'pop3' );
  if( postvalue( 'pop3s' ) != $pop3s ) $attrs['cyrus-pop3s'] = postvalue( 'pop3s' );
  if( postvalue( 'imap' ) != $imap )   $attrs['cyrus-imap'] = postvalue( 'imap' );
  if( postvalue( 'imaps' ) != $imaps ) $attrs['cyrus-imaps'] = postvalue( 'imaps' );
  if( postvalue( 'sieve' ) != $sieve ) $attrs['cyrus-sieve'] = postvalue( 'sieve' );
  if( postvalue( 'http' ) != $http )    $attrs['apache-http'] = postvalue( 'http' );
  if( postvalue( 'amavis' ) != $amavis )  $attrs['postfix-enable-virus-scan'] = postvalue( 'amavis' );
  
  if( !($result = ldap_modify($ldap->connection, "k=kolab,".$_SESSION['base_dn'], $attrs)) ) {
	$errors[] = sprintf( _("LDAP Error: failed to modify kolab configuration object: %s"),
						 ldap_error($ldap->connection));
  }
}

if( $_REQUEST['submitquotawarn'] ) {
  $attrs = array();
  $attrs['cyrus-quotawarn'] = trim( $_REQUEST['quotawarn'] );
  if( !($result = ldap_modify($ldap->connection, "k=kolab,".$_SESSION['base_dn'], $attrs)) ) {
	$errors[] = sprintf(_("LDAP Error: failed to modify kolab configuration object: %s"),
						ldap_error($ldap->connection));
  }
}

if( $_REQUEST['submithttpallowunauthfb'] ) {
  $attrs = array();
  $attrs['apache-allow-unauthenticated-fb'] = postvalue( 'httpallowunauthfb' );
  if( !($result = ldap_modify($ldap->connection, "k=kolab,".$_SESSION['base_dn'], $attrs)) ) {
	$errors[] = sprintf(_("LDAP Error: failed to modify kolab configuration object: %s"),
						ldap_error($ldap->connection));
  }
}

if( $_REQUEST['submitfreebusypast'] ) {
  $attrs = array();
  $value = trim( $_REQUEST['freebusypast'] );
  if( $value == '' ) $value = array();
  $attrs['kolabFreeBusyPast'] = $value;
  if( !($result = ldap_modify($ldap->connection, "k=kolab,".$_SESSION['base_dn'], $attrs)) ) {
	$errors[] = sprintf(_("LDAP Error: failed to modify kolab configuration object: %s"),
						ldap_error($ldap->connection));
  }
}

if( $_REQUEST['submitpostfixmynetworks'] ) {
  $attrs = array();
  $attrs['postfix-mynetworks'] = preg_split( "/[\s,]+/", trim( $_REQUEST['postfixmynetworks'] ) );
  //if( $attrs['postfix-mynetworks'] == '' ) $attrs['postfix-mynetworks'] = array();
  if( !($result = ldap_modify($ldap->connection, "k=kolab,".$_SESSION['base_dn'], $attrs)) ) {
	$errors[] = sprintf(_("LDAP Error: failed to modify kolab configuration object: %s"),
						ldap_error($ldap->connection));
  }
}

if( $_REQUEST['submitpostfixallowunauth'] ) {
  $attrs = array();
  $attrs['postfix-allow-unauthenticated'] = postvalue( 'postfixallowunauth' );
  if( !($result = ldap_modify($ldap->connection, "k=kolab,".$_SESSION['base_dn'], $attrs)) ) {
	$errors[] = sprintf(_("LDAP Error: failed to modify kolab configuration object: %s"),
						ldap_error($ldap->connection));
  }
}

if( $_REQUEST['submitkolabfilter'] ) {
  $attrs = array(
				 'kolabfilter-verify-from-header'        => postvalue( 'kolabfilterverifyfrom' ),
				 'kolabfilter-allow-sender-header'       => postvalue( 'kolabfilterallowsender' ),
				 'kolabfilter-reject-forged-from-header' => $_REQUEST['kolabfilterrejectforgedfrom']=='TRUE'?'TRUE':'FALSE' );
  if( !($result = ldap_modify($ldap->connection, "k=kolab,".$_SESSION['base_dn'], $attrs)) ) {
	$errors[] = sprintf(_("LDAP Error: failed to modify kolab configuration object: %s"),
						ldap_error($ldap->connection));
  }
 }

if( $_REQUEST['submitpostfixrelayhost'] ) {
  $host_val = trim( $_REQUEST['postfixrelayhost'] );
  $port_val = trim( $_REQUEST['postfixrelayport'] );
  if( $host_val == '' ) $host_val = array();
  if( $port_val == '' ) $port_val = array();
  $attrs = array();  
  $attrs['postfix-relayhost'] = $host_val;
  $attrs['postfix-relayport'] = $port_val;
  if( !($result = ldap_modify($ldap->connection, "k=kolab,".$_SESSION['base_dn'], $attrs)) ) {
	$errors[] = sprintf(_("LDAP Error: failed to modify kolab configuration object: %s"),
						ldap_error($ldap->connection));
  }
}

// Change domain constraints
if($_REQUEST['changequota']) {
	extract_ldap_values();
	$domainname = trim($_REQUEST['adestination']);
	// Update LDAP
	if(!$errors && is_array($attrs))
		if(!($result = ldap_modify($ldap->connection, "cn=" . $ldap->escape($domainname)
				. ",cn=domains,cn=internal," . $_SESSION['base_dn'], $attrs)))
			$errors[] = sprintf(_("LDAP Error: failed to modify domain quotas: %s"),
					ldap_error($ldap->connection));
	if(!$errors)
		if($result = setDomainOwner($_REQUEST['adestination'], $_REQUEST['owner']))
			$errors[] = $result;
}

// Delete domain
if( $_REQUEST['deletedestination'] ) {
  extract_ldap_values();
  debug_var_dump($_REQUEST['adestination']);
  $key = array_search( trim($_REQUEST['adestination']),$postfixmydestination);
  if( $key !== false ) {
	unset( $postfixmydestination[ $key ] );
  }
  $postfixmydestination = array_values( $postfixmydestination );
  debug_var_dump($postfixmydestination);
  $attrs = array();
  $attrs['postfix-mydestination'] = $postfixmydestination;
  if( !($result = ldap_modify($ldap->connection, "k=kolab,".$_SESSION['base_dn'], $attrs)) ) {
	$errors[] = sprintf(_("LDAP Error: failed to modify kolab configuration object: %s"),
						ldap_error($ldap->connection));
  }
  $domain_obj_dn = 'cn='.$ldap->escape(trim($_REQUEST['adestination'])).',cn=domains,cn=internal,'.$_SESSION['base_dn'];
  debug("Trying to delete $domain_obj_dn");
  if( !$errors && $ldap->read($domain_obj_dn) && !ldap_delete($ldap->connection, $domain_obj_dn ) ) {
	$errors[] = sprintf(_("LDAP Error: Failed to delete domain object %s: %s"), $domain_obj_dn,
						ldap_error($ldap->connection));
  }
  if($result = removeDomainFromAllCustomers($_REQUEST['adestination']))
	$errors[] = $result;
}
// Add domain
if( $_REQUEST['adddestination'] ) {
  extract_ldap_values();
  if( trim($_REQUEST['adestination']) ) {
	$postfixmydestination[] = $domainname = trim($_REQUEST['adestination']);
	$attrs = array();
	$attrs['postfix-mydestination'] = $postfixmydestination;
	if( !($result = ldap_modify($ldap->connection, "k=kolab,".$_SESSION['base_dn'], $attrs)) ) {
	  $errors[] = sprintf(_("LDAP Error: failed to modify kolab configuration object: %s"),
						  ldap_error($ldap->connection));
	}
	if(empty($errors))
		if($result = addDomainToCustomer($_REQUEST['adestination'], $_REQUEST['owner']))
			$errors[] = $result;
  }
}

// Delete customer
if($_REQUEST['deletecustomer']) {
	$customer_obj_dn = 'cn=' . $ldap->escape($customer_cn = trim($_REQUEST['customer_cn']))
			. ',cn=customers,cn=internal,' . $_SESSION['base_dn'];
	if(!$errors && $ldap->read($customer_obj_dn) && !ldap_delete($ldap->connection, $customer_obj_dn))
		$errors[] = sprintf(_("LDAP Error: Failed to delete internal customer group object %s: %s"),
				$customer_obj_dn, ldap_error($ldap->connection));
	else {
		// Delete customer root object recursively
		$customer_obj_dn = 'cn=' . $ldap->escape(trim($_REQUEST['customer_cn']))
				. ',' . $_SESSION['base_dn'];
		if(!trim($_REQUEST['customer_cn']))
			$errors[] = _("Error deleting customer root object: Customer CN is empty");
		if(!$errors && $ldap->read($customer_obj_dn) && !ldap_delete_recursive($ldap->connection,
				$customer_obj_dn, true))
			$errors[] = sprintf(_("LDAP Error: Failed to delete customer root object %s: %s"),
					$customer_obj_dn, ldap_error($ldap->connection));
	}
	if(empty($errors))
		adjustSessionForCustomerUpdate($customer_cn, 'removed');
}

// Add customer
if($_REQUEST['addcustomer']) {
	$customer_description = trim( $_REQUEST['description'] );
	$customer_cn = trim($_REQUEST['customer_cn']);
	$customer_kolabhomeserver = trim($_REQUEST['kolabhomeserver']);
	$attrs = array();
	$attrs['objectClass'] = array('top', 'kolabNamedObject');
	$attrs['cn'] = $customer_cn;
	// Create customer root object
	if(!($result = ldap_add($ldap->connection, "cn=" . $customer_cn . ","
			. $_SESSION['base_dn'], $attrs)))
		$errors[] = sprintf(_("LDAP Error: failed to add new customer root object: %s"),
				ldap_error($ldap->connection));
	else {
		// Create external addressbook context
		$attrs['cn'] = "external";
		if(!($result = ldap_add($ldap->connection, "cn=external,cn=" . $customer_cn
				. ',' . $_SESSION['base_dn'], $attrs)))
			$errors[] = sprintf(_("LDAP Error: failed to add customer external "
					. "addressbook object: %s"), ldap_error($ldap->connection));
		else {
			// Create internal shared folder context
			$attrs['cn'] = "internal";
			if(!($result = ldap_add($ldap->connection, "cn=internal,cn="
					. $customer_cn . ',' . $_SESSION['base_dn'], $attrs)))
				$errors[] = sprintf(_("LDAP Error: failed to add customer internal "
						. "shared folder object: %s"), ldap_error($ldap->connection));
			else {
				// Create internal customer group object
				$attrs['cn'] = $customer_cn;
				$attrs['description'] = $customer_description;
				$attrs['kolabHomeServer'] = $customer_kolabhomeserver;
				$attrs['member'] = "";
				$attrs['objectClass'] = array('top', 'kolabGroupOfNames');
				if(!($result = ldap_add($ldap->connection, "cn=" . $customer_cn
						. ",cn=customers,cn=internal," . $_SESSION['base_dn'],
						$attrs)))
					$errors[] = sprintf(_("LDAP Error: failed to add internal "
							. "customer group object: %s"),
							ldap_error($ldap->connection));
			}
		}
	}
	if(empty($errors))
		adjustSessionForCustomerUpdate($customer_cn, 'added', $customer_description,
				$customer_kolabhomeserver, isset($customer_disablegroupware)
				&& $customer_disablegroupware == 'TRUE');
}

// Change customer
if($_REQUEST['changecustomer']) {
	$customer_description = trim($_REQUEST['description']);
	$customer_cn = trim($_REQUEST['customer_cn']);
	if($customer_description == '')
		$customer_description = array();
	$attrs = array();
	$attrs['description'] = $customer_description;
	$customer_kolabhomeserver = trim($_REQUEST['kolabhomeserver']);
	$attrs['kolabHomeServer'] = $customer_kolabhomeserver;
	if(empty($errors))
		if(!($result = ldap_modify($ldap->connection, "cn=" . $customer_cn
				. ",cn=customers,cn=internal," . $_SESSION['base_dn'], $attrs)))
			$errors[] = sprintf(_("LDAP Error: failed to modify customer object: %s"),
					ldap_error($ldap->connection));
	if(empty($errors))
		adjustSessionForCustomerUpdate($customer_cn, 'modified', $customer_description, $customer_kolabhomeserver);
}

// Delete kolabhost
if( $_REQUEST['deletekolabhost'] ) {
  extract_ldap_values();
  $key = array_search( trim($_REQUEST['akolabhost']),$kolabhost);
  if( $key !== false ) {
	unset( $kolabhost[ $key ] );
  }
  $kolabhost = array_values( $kolabhost );
  $attrs = array();
  $attrs['kolabhost'] = $kolabhost;
  if( !($result = ldap_modify($ldap->connection, "k=kolab,".$_SESSION['base_dn'], $attrs)) ) {
	$errors[] = sprintf(_("LDAP Error: failed to modify kolab configuration object: %s"),
						ldap_error($ldap->connection));
  }
}

// Add kolabhost
if( $_REQUEST['addkolabhost'] ) {
  extract_ldap_values();
  if( trim($_REQUEST['akolabhost']) ) {
	$kolabhost[] = trim($_REQUEST['akolabhost']);
	$attrs = array();
	$attrs['kolabhost'] = $kolabhost;
	if( !($result = ldap_modify($ldap->connection, "k=kolab,".$_SESSION['base_dn'], $attrs)) ) {
	  $errors[] = sprintf(_("LDAP Error: failed to modify kolab configuration object: %s"),
						  ldap_error($ldap->connection));
	}
  }
}

// Fill in output form
extract_ldap_values();
$entries = array( array( 'service' => 'pop3', 'name'  => _('POP3 Service'), 'enabled' => toboolstr( $pop3 ) ),
				  array( 'service' => 'pop3s', 'name' => _('POP3/SSL service (TCP port 995)'), 'enabled' => toboolstr( $pop3s ) ),
				  array( 'service' => 'imap', 'name'  => _('IMAP Service'), 'enabled' => toboolstr( $imap ) ),
				  array( 'service' => 'imaps', 'name' => _('IMAP/SSL Service (TCP port 993)'), 'enabled' => toboolstr( $imaps ) ),
				  array( 'service' => 'sieve', 'name' => sprintf(_('Sieve service (TCP port %s)'), 2000), 'enabled' => toboolstr( $sieve ) ),
				  array( 'service' => 'http', 'name'  => _('FreeBusy Service via HTTP (in addition to HTTPS)'), 'enabled' => toboolstr( $http ) ),
				  array( 'service' => 'amavis', 'name' => _('Amavis Email Scanning (Virus/Spam)'), 
						 'enabled' => toboolstr( $amavis ) ) );

/**** Check for system aliases ****/
function exists_group( $group ) {
  global $ldap;
  $filter = '(&(objectClass=kolabGroupOfNames)(mail='.$ldap->escape($group).'))';
  $res = $ldap->search( $_SESSION['base_dn'], $filter, array( 'dn' ) );
  return ( $ldap->count($res) > 0 );
}

function _customerOfDomain($d) {
	global $ldap;
	return $ldap->customerOfDomain($d);
}

/**** Insert into template and output ***/
$smarty = new MySmarty();
if(!$access_denied) {
	$smarty->assign( 'errors', $errors );
	$smarty->assign( 'uid', $auth->uid() );
	$smarty->assign( 'group', $auth->group() );
	$smarty->assign( 'page_title', $menuitems[$sidx]['title'] );
	$smarty->assign( 'entries', $entries );
	$smarty->assign( 'quotawarn', $quotawarn );
	$smarty->assign( 'httpallowunauthfb', toboolstr($httpallowunauthfb) );
	$smarty->assign( 'freebusypast', $freebusypast );
	$smarty->assign( 'postfixmydestination', $domains = $ldap->domainsOfSelectedCustomer() );
	$smarty->assign( 'domainowners', array_map('_customerOfDomain', $domains));
	$smarty->assign( 'allcustomers', arrayInsideOut(getNamedCustomerList()));
	$smarty->assign( 'selected_customer_cn', getSelectedCustomerCN());
	$smarty->assign( 'customers', $customers );
	$smarty->assign( 'postfixmynetworks', $postfixmynetworks );
	$smarty->assign( 'postfixallowunauth', toboolstr($postfixallowunauth) );
	$smarty->assign( 'postfixrelayhost', $postfixrelayhost );
	$smarty->assign( 'postfixrelayport', $postfixrelayport );
	$smarty->assign( 'kolabfilterverifyfrom', toboolstr($kolabfilterverifyfrom) );
	$smarty->assign( 'kolabfilterallowsender', toboolstr($kolabfilterallowsender) );
	$smarty->assign( 'kolabfilterrejectforgedfrom', toboolstr($kolabfilterrejectforgedfrom) );
	$smarty->assign( 'kolabhost', $kolabhost );
	$smarty->assign( 'menuitems', $menuitems );
	$smarty->assign( 'submenuitems',
					 array_key_exists('submenu',
									  $menuitems[$sidx])?$menuitems[$sidx]['submenu']:array() );
	$smarty->assign( 'maincontent', 'settings.tpl' );
}

$systemaliasconf = array();

if( $auth->group() == 'admin' ) {
  $domain_count = 0;
  foreach( $ldap->domainsOfSelectedCustomer() as $domain ) {
	if( !exists_group( 'hostmaster@'.$domain ) ||
		!exists_group( 'postmaster@'.$domain ) ||
		!exists_group( 'abuse@'.$domain ) ||
		!exists_group( 'virusalert@'.$domain ) ||
		!exists_group( 'MAILER-DAEMON@'.$domain ) ) {
	  // Ok, user did not set up system aliases
	  $systemaliasconf[] = array( 'n'=>$domain_count, 'domain'=>$domain );
	}
	$domain_count++;
  }
}

$smarty->assign( 'systemaliasconf', $systemaliasconf );
$smarty->display('page.tpl');

/*
  Local variables:
  mode: php
  indent-tabs-mode: t
  tab-width: 4
  buffer-file-coding-system: utf-8
  End:
 */
?>
