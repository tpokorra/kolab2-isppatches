From: Gunnar Wrobel <p@rdus.de>
Subject: [PATCH] t/dimp/H/MS/CopyMessagesWithCtrl

Allow copying messages with Drag&Drop while holding Ctrl.

https://www.intevation.de/roundup/kolab/issue4080

STATUS: MERGED in HEAD but not in FRAMEWORK_3

Signed-off-by: Gunnar Wrobel <p@rdus.de>

diff -Naur a/DimpBase.js b/js/DimpBase.js
--- a/DimpBase.js	2010-04-14 22:21:28.000000000 +0200
+++ b/js/DimpBase.js	2010-04-14 22:20:38.000000000 +0200
@@ -1175,7 +1175,7 @@
     },
 
     /* Drag/Drop handler. */
-    _folderDropHandler: function(drop, drag)
+    _folderDropHandler: function(drop, drag, e)
     {
         var dropbase, sel, uids,
             foldername = drop.readAttribute('mbox'),
@@ -1198,10 +1198,14 @@
                 uids = this.viewport.createSelection('domid', drag.id);
             }
 
-            // Don't allow drag/drop to the current folder.
-            if (uids.size() && this.folder != foldername) {
-                this.viewport.updateFlag(uids, 'deletedmsg', true);
-                DimpCore.doAction('MoveMessage', this.viewport.addRequestParams({ tofld: foldername }), DimpCore.toUIDArray(uids), this.bcache.get('deleteC') || this.bcache.set('deleteC', this._deleteCallback.bind(this)));
+            if (uids.size()) {
+                if (e.ctrlKey) {
+                    DimpCore.doAction('CopyMessage', this.viewport.addRequestParams({ tofld: foldername }), DimpCore.toUIDArray(uids), this.bcache.get('pollFC') || this.bcache.set('pollFC', this._pollFoldersCallback.bind(this)));
+                } else if (this.folder != foldername) {
+                    // Don't allow drag/drop to the current folder.
+                    this.viewport.updateFlag(uids, 'deletedmsg', true);
+                    DimpCore.doAction('MoveMessage', this.viewport.addRequestParams({ tofld: foldername }), DimpCore.toUIDArray(uids), this.bcache.get('deleteC') || this.bcache.set('deleteC', this._deleteCallback.bind(this)));
+                }
             }
         }
     },
@@ -2073,17 +2077,20 @@
 
 DimpBase._folderDropConfig = {
     hoverclass: 'dragdrop',
-    caption: function(drop, drag) {
-        var d = drag.readAttribute('l'),
+    caption: function(drop, drag, e) {
+        var m,
+            d = drag.readAttribute('l'),
             ftype = drop.readAttribute('ftype'),
-            l = drop.readAttribute('l'),
-            m = DIMP.text.moveto;
+            l = drop.readAttribute('l');
         if (drop == $('dropbase')) {
-            return m.replace(/%s/, d).replace(/%s/, DIMP.text.baselevel);
-        } else if (drag.hasClassName('folder')) {
-            return (ftype != 'special' && !this.isSubfolder(drag, drop)) ? m.replace(/%s/, d).replace(/%s/, l) : '';
+            return DIMP.text.moveto.replace(/%s/, d).replace(/%s/, DIMP.text.baselevel);
         } else {
-            return ftype != 'container' ? m.replace(/%s/, this._dragCaption()).replace(/%s/, l) : '';
+            m = (e.ctrlKey) ? DIMP.text.copyto : DIMP.text.moveto;
+            if (drag.hasClassName('folder')) {
+                return (ftype != 'special' && !this.isSubfolder(drag, drop)) ? m.replace(/%s/, d).replace(/%s/, l) : '';
+            } else {
+                return ftype != 'container' ? m.replace(/%s/, this._dragCaption()).replace(/%s/, l) : '';
+            }
         }
     }.bind(DimpBase),
     onDrop: DimpBase._folderDropHandler.bind(DimpBase)
diff -Naur a/dragdrop.js b/js/dragdrop.js
--- a/dragdrop.js	2010-04-14 22:21:28.000000000 +0200
+++ b/js/dragdrop.js	2010-04-14 22:20:38.000000000 +0200
@@ -1 +1,452 @@
-var DragDrop={Drags:{drags:$H(),register:function(a){if(!this.drags.size()){if(!this.div){this.div=new Element("DIV",{className:a.options.classname}).hide()}$(document.body).insert(this.div)}this.drags.set(a.element.readAttribute("id"),a)},unregister:function(a){if(this.drag==a.element){this.drag.deactivate()}this.drags.unset(a.element.readAttribute("id"));if(!this.drags.size()&&this.div){this.div.remove()}},get_drag:function(a){return this.drags.get(Object.isElement(a)?$(a).readAttribute("id"):a)},activate:function(a){if(this.drag){this.deactivate()}this.drag=a;this.mousemoveE=a._mouseMove.bindAsEventListener(a);this.mouseupE=a._mouseUp.bindAsEventListener(a);document.observe("mousemove",this.mousemoveE);document.observe("mouseup",this.mouseupE)},deactivate:function(){if(this.drag){this.drag=null;document.stopObserving("mousemove",this.mousemoveE);document.stopObserving("mouseup",this.mouseupE)}}},Drops:{drops:$H(),register:function(a){this.drops.set(a.element.readAttribute("id"),a)},unregister:function(a){if(this.drop==a.element){this.drop=null}this.drops.unset(a.element.readAttribute("id"))},get_drop:function(a){return this.drops.get(Object.isElement(a)?$(a).readAttribute("id"):a)}},validDrop:function(a){var b=DragDrop.Drops.drop;return(b&&a&&a!=b.element&&(!b.options.accept.size()||b.options.accept.include(a.tagName)))}},Drag=Class.create({initialize:function(a){this.element=$(a);this.options=Object.extend({caption:"",classname:"drag",constraint:null,ghosting:false,scroll:null,snap:null,threshold:0,onDrag:null,onEnd:null,onStart:null},arguments[1]||{});this.mousedownE=this._mouseDown.bindAsEventListener(this);this.element.observe("mousedown",this.mousedownE);if(this.options.scroll){this.options.scroll=$(this.options.scroll)}DragDrop.Drags.register(this);if(Prototype.Browser.IE){this.element.observe("selectstart",Event.stop)}else{if(Prototype.Browser.Gecko){this.element.setStyle({MozUserSelect:"none"})}}},destroy:function(){this.element.stopObserving("mousedown",this.mousedownE);DragDrop.Drags.unregister(this)},_mouseDown:function(a){$(document.body).setStyle({cursor:"default"});DragDrop.Drags.activate(this);this.move=0;this.wasDragged=false;this.lastdrag=this.lastcaption=null;if(Object.isFunction(this.options.onStart)){this.options.onStart(this,a)}if(!Prototype.Browser.IE&&!Prototype.Browser.Gecko){a.stop()}},_mouseMove:function(f){var b,c,a,d;if(++this.move<=this.options.threshold){return}this.lastCoord=d=[f.pointerX(),f.pointerY()];if(this.options.ghosting){if(!this.ghost){b=this.element.offsetLeft;c=this.element.offsetTop;this.ghost=$(this.element.cloneNode(true)).writeAttribute("id",null).setOpacity(0.7).clonePosition(this.element,{setLeft:false,setTop:false}).setStyle({left:b+"px",position:"absolute",top:c+"px",zIndex:parseInt(this.element.getStyle("zIndex"))+1});this.element.insert({before:this.ghost});a=this.ghost.viewportOffset();this.ghostOffset=[a[0]-b,a[1]-c]}d[0]-=this.ghostOffset[0];d[1]-=this.ghostOffset[1];switch(this.options.constraint){case"horizontal":d[1]=this.ghost.offsetTop;break;case"vertical":d[0]=this.ghost.offsetLeft;break}if(this.options.snap){d=this.options.snap(d[0],d[1],this.element)}if(this.options.offset){d[0]+=this.options.offset.x;d[1]+=this.options.offset.y}this._setContents(this.ghost,d[0],d[1])}this._onMoveDrag(d);if(Object.isFunction(this.options.onDrag)){this.options.onDrag(this,f)}this.wasDragged=true;if(this.options.scroll){this._onMoveScroll()}},_mouseUp:function(a){var b=DragDrop.Drops.drop;this._stopScrolling();if(this.ghost){this.ghost.remove();this.ghost=null}DragDrop.Drags.div.hide();if(DragDrop.validDrop(this.element)&&Object.isFunction(b.options.onDrop)){b.options.onDrop(b.element,this.element)}DragDrop.Drags.deactivate();if(Object.isFunction(this.options.onEnd)){this.options.onEnd(this,a)}},_onMoveDrag:function(g){var f,c,e,b,a,h=DragDrop.Drops.drop,i=DragDrop.Drags.div;if(h&&h.element!=this.lastdrag){if(DragDrop.validDrop(this.element)){b=h.options.caption;if(b){c=Object.isFunction(b)?b(h.element,this.element):b;if(c&&h.options.hoverclass){e=h.options.hoverclass}a=true}}else{a=true}this.lastdrag=h.element}else{if((!h&&this.lastdrag)||(this.move==(this.options.threshold+1))){a=true;this.lastdrag=null}}if(a){if(!c){f=this.options.caption;c=Object.isFunction(f)?f(this.element):f}this.lastcaption=c;i.update(c).writeAttribute({className:e||this.options.classname});if(c.empty()){i.hide()}}if(!this.lastcaption.empty()){this._setContents(i,g[0]+15,g[1]+(this.ghost?(this.ghost.getHeight()+5):5))}},_onMoveScroll:function(){this._stopScrolling();var e,d,b,a=this.options.scroll,c=a.getDimensions();if(a.scrollHeight==c.height){return}e=document.viewport.getScrollOffsets();d=a.viewportOffset(),b=[0,0];d[0]+=a.scrollLeft+e.left;d[2]=d[0]+c.width;if(this.lastCoord[0]>d[2]||this.lastCoord[0]<d[0]){return}d[1]+=a.scrollTop+e.top;d[3]=d[1]+c.height;if(this.lastCoord[1]<d[1]){b[1]=this.lastCoord[1]-d[1]}if(this.lastCoord[1]>d[3]){b[1]=this.lastCoord[1]-d[3]}if(b[0]||b[1]){this.lastScrolled=new Date();this.scrollInterval=setInterval(this._scroll.bind(this,b[0]*15,b[1]*15),10)}},_stopScrolling:function(){if(this.scrollInterval){clearInterval(this.scrollInterval);this.scrollInterval=null}},_scroll:function(a,e){var c=new Date(),d=c-this.lastScrolled,b=this.options.scroll;this.lastScrolled=c;b.scrollTop+=e*d/1000},_setContents:function(c,a,e){var d=document.viewport.getDimensions(),b=c.getDimensions();if((a+b.width>d.width)||(e+b.height>d.height)){c.hide()}else{c.setStyle({left:a+"px",top:e+"px"}).show()}}}),Drop=Class.create({initialize:function(a){this.element=$(a);this.options=Object.extend({accept:[],caption:"",hoverclass:"",onDrop:null,onOut:null,onOver:null},arguments[1]||{});this.mouseoverE=this._mouseOver.bindAsEventListener(this);this.mouseoutE=this._mouseOut.bindAsEventListener(this);this.element.observe("mouseover",this.mouseoverE);this.element.observe("mouseout",this.mouseoutE);DragDrop.Drops.register(this)},destroy:function(){this.element.stopObserving("mouseover",this.mouseoverE);this.element.stopObserving("mouseout",this.mouseoutE);DragDrop.Drops.unregister(this)},_mouseOver:function(a){if(DragDrop.Drags.drag){DragDrop.Drops.drop=this;if(Object.isFunction(this.options.onOver)){this.options.onOver(this.element,DragDrop.Drags.drag)}}},_mouseOut:function(a){if(Object.isFunction(this.options.onOut)){this.options.onOut(this.element,DragDrop.Drags.drag)}DragDrop.Drops.drop=null}});
\ No newline at end of file
+/**
+ * dragdrop.js - A minimalist library to handle drag/drop actions.
+ * Requires prototype.js 1.6.0.2+
+ *
+ * Adapted from SkyByte.js/SkyByteDD.js v1.0-beta, May 17 2007
+ *   (c) 2007 Aleksandras Ilarionovas (Alex)
+ *   http://www.skybyte.net/scripts/
+ *
+ * Scrolling and ghosting code adapted from script.aculo.us dragdrop.js v1.8.0
+ *   (c) 2005-2007 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)
+ *   (c) 2005-2007 Sammi Williams (http://www.oriontransfer.co.nz, sammi@oriontransfer.co.nz)
+ *
+ * The original scripts were freely distributable under the terms of an
+ * MIT-style license.
+ *
+ * Usage:
+ *   new Drag(element, {
+ *       classname: '',           // Class name of the drag element
+ *       caption: '',             // Either string or function to set caption
+ *                                // on mouse move
+ *       ghosting: false,         // Show ghost outline when dragging.
+ *       offset: { x:0, y:0 },    // An offset to apply to ghosted elements.
+ *       scroll: element,         // Scroll this element when above/below.
+ *                                // Only working for vertical elements
+ *       snap: null,              // If ghosting, snap allows to specify
+ *                                // coords at which the ghosted image will
+ *                                // "snap" into place.
+ *       threshold: 0,            // Move threshold
+ *       // For the following functions, d = drop element, e = event object
+ *       onStart: function(d,e),  // A function to run on mousedown
+ *       onDrag: function(d,e),   // A function to run on mousemove
+ *       onEnd: function(d,e)     // A function to run on mouseup
+ *   });
+ *
+ *   new Drop(element, {
+ *       accept: [],           // Accept filter by tag name(s) or leave empty
+ *                             // to accept all tags
+ *       caption: '',          // Either string or function to set caption on
+ *                             // mouse over
+ *       hoverclass: '',       // Change the drag element to this class when
+ *                             // hovering over an element.
+ *       onDrop: function(drop,drag)  // Function fired when mouse button
+ *                                    // released (a/k/a a drop event)
+ *       onOver: function(drop,drag)  // Function fired when mouse over zone
+ *       onOut: function(drop,drag)   // Function fired when mouse leaves the
+ *                                    // zone
+ *  });
+ *
+ * $Horde
+ *
+ * @author Michael Slusarz <slusarz@curecanti.org>
+ */
+
+var DragDrop = {
+    Drags: {
+        drags: $H(),
+
+        register: function(obj)
+        {
+            if (!this.drags.size()) {
+                if (!this.div) {
+                    this.div = new Element('DIV', { className: obj.options.classname }).hide();
+                }
+                $(document.body).insert(this.div);
+            }
+
+            this.drags.set(obj.element.readAttribute('id'), obj);
+        },
+
+        unregister: function(obj)
+        {
+            if (this.drag == obj.element) {
+                this.drag.deactivate();
+            }
+
+            this.drags.unset(obj.element.readAttribute('id'));
+
+            if (!this.drags.size() && this.div) {
+                this.div.remove();
+            }
+        },
+
+        get_drag: function(el)
+        {
+            return this.drags.get(Object.isElement(el) ? $(el).readAttribute('id') : el);
+        },
+
+        activate: function(drag)
+        {
+            if (this.drag) {
+                this.deactivate();
+            }
+            this.drag = drag;
+            this.mousemoveE = drag._mouseMove.bindAsEventListener(drag);
+            this.mouseupE = drag._mouseUp.bindAsEventListener(drag);
+            document.observe('mousemove', this.mousemoveE);
+            document.observe('mouseup', this.mouseupE);
+        },
+
+        deactivate: function()
+        {
+            if (this.drag) {
+                this.drag = null;
+                document.stopObserving('mousemove', this.mousemoveE);
+                document.stopObserving('mouseup', this.mouseupE);
+            }
+        }
+    },
+
+    Drops: {
+        drops: $H(),
+
+        register: function(obj)
+        {
+            this.drops.set(obj.element.readAttribute('id'), obj);
+        },
+
+        unregister: function(obj)
+        {
+            if (this.drop == obj.element) {
+                this.drop = null;
+            }
+
+            this.drops.unset(obj.element.readAttribute('id'));
+        },
+
+        get_drop: function(el)
+        {
+            return this.drops.get(Object.isElement(el) ? $(el).readAttribute('id') : el);
+        }
+    },
+
+    validDrop: function(el)
+    {
+        var d = DragDrop.Drops.drop;
+        return (d &&
+                el &&
+                el != d.element &&
+                (!d.options.accept.size() ||
+                 d.options.accept.include(el.tagName)));
+    }
+},
+
+Drag = Class.create({
+
+    initialize: function(el) {
+        this.element = $(el);
+        this.options = Object.extend({
+            caption: '',
+            classname: 'drag',
+            constraint: null,
+            ghosting: false,
+            scroll: null,
+            snap: null,
+            threshold: 0,
+            onDrag: null,
+            onEnd: null,
+            onStart: null
+        }, arguments[1] || {});
+        this.mousedownE = this._mouseDown.bindAsEventListener(this);
+        this.element.observe('mousedown', this.mousedownE);
+        if (this.options.scroll) {
+            this.options.scroll = $(this.options.scroll);
+        }
+        DragDrop.Drags.register(this);
+
+        // Disable text selection.
+        // See: http://ajaxcookbook.org/disable-text-selection/
+        // Stopping the event on mousedown works on all browsers, but avoid
+        // that if possible because it will prevent any event handlers further
+        // up the DOM tree from firing.
+        if (Prototype.Browser.IE) {
+            this.element.observe('selectstart', Event.stop);
+        } else if (Prototype.Browser.Gecko) {
+            this.element.setStyle({ MozUserSelect: 'none' });
+        }
+    },
+
+    destroy: function()
+    {
+        this.element.stopObserving('mousedown', this.mousedownE);
+        DragDrop.Drags.unregister(this);
+    },
+
+    _mouseDown: function(e)
+    {
+        $(document.body).setStyle({ cursor: 'default' });
+        DragDrop.Drags.activate(this);
+        this.move = 0;
+        this.wasDragged = false;
+        this.lastcaption = null;
+
+        if (Object.isFunction(this.options.onStart)) {
+            this.options.onStart(this, e);
+        }
+
+        if (!Prototype.Browser.IE && !Prototype.Browser.Gecko) {
+            e.stop();
+        }
+    },
+
+    _mouseMove: function(e)
+    {
+        var oleft, otop, vo, xy;
+
+        if (++this.move <= this.options.threshold) {
+            return;
+        }
+
+        this.lastCoord = xy = [ e.pointerX(), e.pointerY() ];
+
+        if (this.options.ghosting) {
+            if (!this.ghost) {
+                oleft = this.element.offsetLeft;
+                otop = this.element.offsetTop;
+                this.ghost = $(this.element.cloneNode(true)).writeAttribute('id', null).setOpacity(0.7).clonePosition(this.element, { setLeft: false, setTop: false }).setStyle({ left: oleft + 'px', position: 'absolute', top: otop + 'px', zIndex: parseInt(this.element.getStyle('zIndex')) + 1 });
+                this.element.insert({ before: this.ghost });
+                vo = this.ghost.viewportOffset();
+                this.ghostOffset = [ vo[0] - oleft, vo[1] - otop ];
+            }
+
+            xy[0] -= this.ghostOffset[0];
+            xy[1] -= this.ghostOffset[1];
+
+            switch (this.options.constraint) {
+            case 'horizontal':
+                xy[1] = this.ghost.offsetTop;
+                break;
+
+            case 'vertical':
+                xy[0] = this.ghost.offsetLeft;
+                break;
+            }
+
+            if (this.options.snap) {
+                xy = this.options.snap(xy[0], xy[1], this.element);
+            }
+
+            if (this.options.offset) {
+                xy[0] += this.options.offset.x;
+                xy[1] += this.options.offset.y;
+            }
+
+            this._setContents(this.ghost, xy[0], xy[1]);
+        }
+
+        this._onMoveDrag(xy, e);
+
+        if (Object.isFunction(this.options.onDrag)) {
+            this.options.onDrag(this, e);
+        }
+
+        this.wasDragged = true;
+
+        if (this.options.scroll) {
+            this._onMoveScroll();
+        }
+    },
+
+    _mouseUp: function(e)
+    {
+        var d = DragDrop.Drops.drop;
+
+        this._stopScrolling();
+
+        if (this.ghost) {
+            this.ghost.remove();
+            this.ghost = null;
+        }
+        DragDrop.Drags.div.hide();
+
+        if (DragDrop.validDrop(this.element) &&
+            Object.isFunction(d.options.onDrop)) {
+            d.options.onDrop(d.element, this.element, e);
+        }
+
+        DragDrop.Drags.deactivate();
+
+        if (Object.isFunction(this.options.onEnd)) {
+            this.options.onEnd(this, e);
+        }
+    },
+
+    _onMoveDrag: function(xy, e)
+    {
+        var c_opt, caption, cname, d_cap,
+            d = DragDrop.Drops.drop,
+            div = DragDrop.Drags.div,
+            d_update = true;
+
+        if (d && DragDrop.validDrop(this.element)) {
+            d_cap = d.options.caption;
+            if (d_cap) {
+                caption = Object.isFunction(d_cap) ? d_cap(d.element, this.element, e) : d_cap;
+                if (caption && d.options.hoverclass) {
+                    cname = d.options.hoverclass;
+                }
+            } else {
+                d_update = false;
+            }
+        }
+
+        if (d_update) {
+            if (!caption) {
+                c_opt = this.options.caption;
+                caption = Object.isFunction(c_opt) ? c_opt(this.element) : c_opt;
+            }
+            if (caption != this.lastcaption) {
+                this.lastcaption = caption;
+                div.update(caption).writeAttribute({ className: cname || this.options.classname });
+                if (caption.empty()) {
+                    div.hide();
+                }
+            }
+        }
+
+        if (!this.lastcaption.empty()) {
+            this._setContents(div, xy[0] + 15, xy[1] + (this.ghost ? (this.ghost.getHeight() + 5) : 5));
+        }
+    },
+
+    _onMoveScroll: function()
+    {
+        this._stopScrolling();
+
+        var delta, p, speed,
+            s = this.options.scroll,
+            dim = s.getDimensions();
+
+        // No need to scroll if element is not current scrolling.
+        if (s.scrollHeight == dim.height) {
+            return;
+        }
+
+        delta = document.viewport.getScrollOffsets();
+        p = s.viewportOffset(),
+        speed = [ 0, 0 ];
+
+        p[0] += s.scrollLeft + delta.left;
+        p[2] = p[0] + dim.width;
+
+        // Only scroll if directly above/below element
+        if (this.lastCoord[0] > p[2] ||
+            this.lastCoord[0] < p[0]) {
+            return;
+        }
+
+        p[1] += s.scrollTop + delta.top;
+        p[3] = p[1] + dim.height;
+
+        // Left scroll
+        //if (this.lastCoord[0] < p[0]) {
+        //    speed[0] = this.lastCoord[0] - p[0];
+        //}
+        // Top scroll
+        if (this.lastCoord[1] < p[1]) {
+            speed[1] = this.lastCoord[1] - p[1];
+        }
+        // Scroll right
+        //if (this.lastCoord[0] > p[2]) {
+        //    speed[0] = this.lastCoord[0] - p[2];
+        //}
+        // Scroll left
+        if (this.lastCoord[1] > p[3]) {
+            speed[1] = this.lastCoord[1] - p[3];
+        }
+
+        if (speed[0] || speed[1]) {
+            this.lastScrolled = new Date();
+            this.scrollInterval = setInterval(this._scroll.bind(this, speed[0] * 15, speed[1] * 15), 10);
+        }
+    },
+
+    _stopScrolling: function()
+    {
+        if (this.scrollInterval) {
+            clearInterval(this.scrollInterval);
+            this.scrollInterval = null;
+        }
+    },
+
+    _scroll: function(x, y)
+    {
+        var current = new Date(),
+            delta = current - this.lastScrolled,
+            s = this.options.scroll;
+        this.lastScrolled = current;
+
+        //s.scrollLeft += x * delta / 1000;
+        s.scrollTop += y * delta / 1000;
+    },
+
+    _setContents: function(elt, x, y)
+    {
+        var d_pos = document.viewport.getDimensions(),
+            e_pos = elt.getDimensions();
+
+        if ((x + e_pos.width > d_pos.width) ||
+            (y + e_pos.height > d_pos.height)) {
+            elt.hide();
+        } else {
+            elt.setStyle({ left: x + 'px', top: y + 'px' }).show();
+        }
+    }
+
+}),
+
+Drop = Class.create({
+
+    initialize: function(el)
+    {
+        this.element = $(el);
+        this.options = Object.extend({
+            accept: [],
+            caption: '',
+            hoverclass: '',
+            onDrop: null,
+            onOut: null,
+            onOver: null
+        }, arguments[1] || {});
+        this.mouseoverE = this._mouseOver.bindAsEventListener(this);
+        this.mouseoutE = this._mouseOut.bindAsEventListener(this);
+        this.element.observe('mouseover', this.mouseoverE);
+        this.element.observe('mouseout', this.mouseoutE);
+        DragDrop.Drops.register(this);
+    },
+
+    destroy: function()
+    {
+        this.element.stopObserving('mouseover', this.mouseoverE);
+        this.element.stopObserving('mouseout', this.mouseoutE);
+        DragDrop.Drops.unregister(this);
+    },
+
+    _mouseOver: function(e)
+    {
+        if (DragDrop.Drags.drag) {
+            DragDrop.Drops.drop = this;
+            if (Object.isFunction(this.options.onOver)) {
+                this.options.onOver(this.element, DragDrop.Drags.drag);
+            }
+        }
+    },
+
+    _mouseOut: function(e)
+    {
+        if (Object.isFunction(this.options.onOut)) {
+            this.options.onOut(this.element, DragDrop.Drags.drag);
+        }
+        DragDrop.Drops.drop = null;
+    }
+});
diff -Naur a/src/dragdrop.js b/js/src/dragdrop.js
--- a/src/dragdrop.js	2010-04-14 22:21:28.000000000 +0200
+++ b/js/src/dragdrop.js	2010-04-14 22:20:38.000000000 +0200
@@ -188,7 +188,7 @@
         DragDrop.Drags.activate(this);
         this.move = 0;
         this.wasDragged = false;
-        this.lastdrag = this.lastcaption = null;
+        this.lastcaption = null;
 
         if (Object.isFunction(this.options.onStart)) {
             this.options.onStart(this, e);
@@ -244,7 +244,7 @@
             this._setContents(this.ghost, xy[0], xy[1]);
         }
 
-        this._onMoveDrag(xy);
+        this._onMoveDrag(xy, e);
 
         if (Object.isFunction(this.options.onDrag)) {
             this.options.onDrag(this, e);
@@ -271,7 +271,7 @@
 
         if (DragDrop.validDrop(this.element) &&
             Object.isFunction(d.options.onDrop)) {
-            d.options.onDrop(d.element, this.element);
+            d.options.onDrop(d.element, this.element, e);
         }
 
         DragDrop.Drags.deactivate();
@@ -281,30 +281,23 @@
         }
     },
 
-    _onMoveDrag: function(xy)
+    _onMoveDrag: function(xy, e)
     {
-        var c_opt, caption, cname, d_cap, d_update,
+        var c_opt, caption, cname, d_cap,
             d = DragDrop.Drops.drop,
-            div = DragDrop.Drags.div;
+            div = DragDrop.Drags.div,
+            d_update = true;
 
-        if (d && d.element != this.lastdrag) {
-            if (DragDrop.validDrop(this.element)) {
-                d_cap = d.options.caption;
-                if (d_cap) {
-                    caption = Object.isFunction(d_cap) ? d_cap(d.element, this.element) : d_cap;
-                    if (caption && d.options.hoverclass) {
-                        cname = d.options.hoverclass;
-                    }
-                    d_update = true;
+        if (d && DragDrop.validDrop(this.element)) {
+            d_cap = d.options.caption;
+            if (d_cap) {
+                caption = Object.isFunction(d_cap) ? d_cap(d.element, this.element, e) : d_cap;
+                if (caption && d.options.hoverclass) {
+                    cname = d.options.hoverclass;
                 }
             } else {
-                d_update = true;
+                d_update = false;
             }
-            this.lastdrag = d.element;
-        } else if ((!d && this.lastdrag) ||
-                   (this.move == (this.options.threshold + 1))) {
-            d_update = true;
-            this.lastdrag = null;
         }
 
         if (d_update) {
@@ -312,10 +305,12 @@
                 c_opt = this.options.caption;
                 caption = Object.isFunction(c_opt) ? c_opt(this.element) : c_opt;
             }
-            this.lastcaption = caption;
-            div.update(caption).writeAttribute({ className: cname || this.options.classname });
-            if (caption.empty()) {
-                div.hide();
+            if (caption != this.lastcaption) {
+                this.lastcaption = caption;
+                div.update(caption).writeAttribute({ className: cname || this.options.classname });
+                if (caption.empty()) {
+                    div.hide();
+                }
             }
         }
 
diff -Naur /kolab/var/kolab/www/client/dimp/lib/DIMP.php b/lib/DIMP.php
--- /kolab/var/kolab/www/client/dimp/lib/DIMP.php	2010-04-14 22:21:28.000000000 +0200
+++ b/lib/DIMP.php	2010-04-14 22:20:38.000000000 +0200
@@ -215,6 +215,7 @@
             'showtext' => _("Show Quoted Text"),
             'lines' => _("lines"),
             'ok' => _("Ok"),
+            'copyto' => _("Copy %s to %s"),
             'moveto' => _("Move %s to %s"),
             'baselevel' => _("base level of the folder tree"),
             'cancel' => _("Cancel"),
